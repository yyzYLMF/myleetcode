/**********
@Author: yang
content: leetcode summary
**********/

NOTICE:
*   有一些亮点或者是某些重要算法的雏形
**  有再做一遍的必要，可以从中学到知识
*** 非常重要的题，必须多做几遍
(github大牛: github.com/iphkwan/leetcode)

LEETCODE 总结：
1.  (*)2Sum算法，排序从两头往中间找，可以与后面的3Sum 4Sum一起看
2.  (**)整体很简单就是模拟各个位相加，设置一个进位，但这个题里面有很多细节，2颗星是给他的细节的
3.  简单模拟题，找最长没重复子串，从头开始遍历，如果没有在之前出现过的字母则添加，否则从出现过的位置的下一位开始继续遍历
4.  (***)要求算法复杂度位log(m+n)，这是重点，这道题要转换成找第k大的数，而因为所给的两个数组是已经排过序了所以只用log(m+n)，而编程之美上没没有排序的所以要NlogK
5.  (***)遍历所有对称点而不是起始点，通过增加间隔符将奇偶一起考虑是个亮点，核心算法是Manacher算法（利用之前的结果简化第i点计算）
6.  首先要知道ZigZag什么意思，然后找规律实现
7.  从后往前按位处理就好了，最后小心别溢出
8.  最大的难点是要atoi的功能要了解，其他的就是越界问题了
9.  (*)判断是不是回文数,要求不能有额外空间,先统计位数,然后每次取出最高位和最低位进行比较即可,在递进的时候注意细节
10. (**)正则表达式匹配，最大的难点是回溯，处理好*情况就ok了（与44题很像）
11. (*)贪心的遍历，从两头开始向中间汇聚，当然这种算法背后隐含着很多证明
12. (***)Int2罗马,最大的难点是看懂罗马数字和阿拉伯数字转换
13. 罗马2INt,大在小的左边直接加,小的在大的左边要减去小的
14. (**)分治法,多个链表的公共前缀
15. (**)3Sum,在2Sum的基础上，先排序，然后从小到大确定第一个元素，然后在后面的区间内用2Sum找到满足要求的下标，避免重复
16. (**)3Sum closest,与15题类似，只是一个是找相等，一个是找最相似
17. 就是递归，将每个数字对应的所有可能存到map中，然后针对每一位遍历所有可能，注意只有0,1都是空  
18. (**)4Sum,可以将所有k-sum问题转换成2-sum，这样复杂度就为O(N^(k-1))，但是4Sum可以用hasmap来实现，用hasmap来搜索某个值是否存在只用O(1)，所以2Sum可以是O(n)的，n是遍历一遍，所以4Sum先将两个数的值存到hasmap中，然后遍历前2个数的所有可能，看hasmap中是否存在target-(a1+a2)，最后复杂度就是O(n^2)
19. 设置一个间隔位n的区间，然后设置两个指针分别指向头尾，然后递进，当到达尾部时，头指针为要删除的节点
20. 括号匹配，用栈就ok了
21. 简单题，两个有序链表合并起来(github上大牛给的算法很精炼)
22. 回溯问题，不难，递归调用就ok(github上的大牛方法很简单，不需要用stack来存储是否匹配，只需要记录左右括号的个数)
23. (**)多个链表合并是21题的延伸，思维不能太局限，原始数据可以用二分处理，数据组也可以用二分处理，时间复杂度为O(NlogK)，github大牛给的使用priority_queue实现是O(N)
24. 交换连表中的两个数，指针操作，写代码前先在纸上模拟可以避免一些错误(大牛很喜欢用指针的指针来操作)
25. (*)首先是理解题目意思中间是要逆序不是交换，然后剩下的就是链表操作，其中的亮点是如何在不申请多余空间的前提下逆序一个链表(pdf版大牛的递归方法也不错，github大牛的方法没看懂)
26. (**)经典题，去掉重复获得新的长度，用unique实现，github大牛的方法很精髓，用github的方法才是正解
27. 简单题，删除目标值元素并返回剩余长度，因为题目没要求剩余的元素有序，所以把删除的后移就好了
28. (**)查询是否包含某个子串，使用string自带的find函数，题目最初的意思是自己实现，用KMP算法再做一遍
29. (***)这是个好题，用减法来实现除法，就是将被除数想成(2^n+...+..)*除数的形式来处理，github上的算法虽然代码简洁，但是思路和我的一样而且效率不一定高
30. (**)返回L中元素出现在S中的位置，关键是如何判断S的子串是L中元素的全排列，我的想法虽然与github大牛一样，但是他使用map来进行处理，算法就变得很简洁高效
31. 不难，关键是要知道什么样的排列是当前排列的下一个排列
32. (**)思路和我的一样，都是在遇到反括号的时候才计算长度并更新，但是github大牛使用了贪心的思想减少了很多计算长度时候的开销，不错
33. 二分查找，就是在mid不等于target的时候多一个判断
34. 二分查找，我的算法虽然AC了但是事件复杂度最差为O(N)，而github大牛的算法是分别用二分查找找出左边和右边的下标（右边的mid=(low+high+1)/2），它的算法是O(longN)
35. 二分查找，当low+1<high时退出，然后逐个分析，github使用mid=(low+high+1)/2方法，然后在对low判断后得出答案，能比我的简洁一点
36. 判断数读是否合理，分别队行、列以及小块进行判断
37. (*)回溯递归，先遍历整个矩阵存储到行、列和小块中，然后递归遍历所有可能，填数字
38. 不难，首先要理解题目意思，是要返回第n个结果，不是“读n”，还有一点是不会出现3个以上连续出现的数字，所以我的程序有点啰嗦
39. 不难，就是典型的递归回溯，本来想用二分法来查找最大的插入值，但是结果反而不好，应该是用到函数调用还有数据规模小导致的
40. 39题的延伸，还是递归回溯，每个元素只能用一次（不是每个值只能出现一次），有一种写法可以不用在写个函数判断重复，就是for循环中保证每次加入的值不会重复就好了
41. (***)好题，这是一类题，将元素放到它该去的地方然后再进行处理，这道题可以通过值来确定它该去的地方，有些题要用一个变量存储它该去的地方
42. (*)一个贪心问题，先找到最大隔板，然后分别从左边和右边遍历，叠加可以灌水的地方
43. (*)经典题目，大数相乘，用乘数从高到低每一位去乘被乘数，然后将结果相加(ab*cde=((ab*c)10+ab*d)*10+ab*e)
44. (**)通配符匹配，虽然与第10题很像，但是这里的*可以匹配任意个任何字符，而正则表达式中的*是前一个字符的任意多次，所以正则表达式匹配用回溯递归来判断*的使用次数不会太多，而通配符使用回溯递归来确定*的使用次数会严重超时，而本题使用贪心+回溯，记录最近一次*出现的位置，每次匹配不成功只回溯到最近的*处。
45. (*)贪心，选择下跳到达位置最远的点作为这次跳越的目的点，能到达地点越远可能性就越多，如果有最优点那么我们算法一定能找到。
46, 全排列，回溯，用一个数组来存储该数是否被使用过（这道题没有要求去掉重复的，47题要求检查重复）
47. (*)46题的延伸，还是回溯但是要去掉重复的，该题去掉重复的方法是我做leetcode时最常用的方法。
48. 不难，几何问题，矩形旋转90度，先按主对角线对折，然后左右翻转
49. (*)首先题目的意思是给一组字符串，找出所有由相同字母组成的字符串，第二次想还是没有想到用map<string,vector<string> >的数据结构，多看看
50. 次方运算，与29题很像，将n看成ak*2^k+...+a0*2^0的形式，而这道题要小心指数为负数的情况
51. (***)经典回溯问题，N皇后问题，就是要小心对角线有两个
52. 和51题基本上一样，一个返回所有可能，一个返回所有可能数目，github大牛用位操作实现的，很简洁（但是感觉掌握不好）
53. (*)求最大和的连续子序列，贪心问题（如果用分治法的画，对于每一个子问题还要记录它最大子序列组成元素的下标，才好合并）
54. 就是一个模拟题，右下左上添加，就是要注意到头后要转向
55. 与45题很像，比45题要求简单，还是贪心做，遇到走不动了返回false
56. 不难，按照开始时间排序，从头到尾遍历，能合并的合并
57. (*)不难，就是一个逻辑严密性的题，和56题一样区间合并
58. 简单题，求最后一个单词的长度
59. 54题的变形，我还是用啰嗦的模拟方法，github大神计算出了对应的关系，每次循环填4个值
60. (***)好题，是46、47题的变形，不过这道题只需要返回第k个排序，所以不需要用递归找出所有结果，第k位应该填几要看剩下的值是(k-1)!的多少倍
61. (*)第二次看还是没理解题目意思，题目是将链表右移N步，N可能大于链表长度
62. 不难，简单的动态规划
63. 不难，与62题很像，就是加了障碍物，注意dp[0][0]位置和初始化情况就ok
64. 不难，与62一样就是加了个外壳，62-64是一个类型的动态规划题
65. (**)判断一个数是否是合理的科学技术法表示的，因为不知道什么形式是正确的，所以比较难，细节要考虑的有：前后的空格；小数点只能出现一次且只能出现在数值部分；e或者E只能出现一次而且出现时之前一定有合法数字；加减号只能出现在首部以及e的后面一位；
66. 简单题，就是大数加一，主要小心所有位都加完了但是进位还为1的时候要在首部加1.
67. 简单题，二进制大数相加
68. (**)复杂模拟题，关键是当下一个单词放不到这一行时该如何处理
69. (*)求x的平方根，在一定区域内二分查找，比方说这道题中x为int型，所以结果肯定小于2^16，不能用if(x/mid == mid)来防止越界(131/11 == 11为true)
70. 简单题，上楼梯，简单的动态规划
71. 不难，模拟题，每次遇到'/'处理一下，小心几个细节：怎么退栈都会有一个'/'；输入结尾不一定是'/'
72. (*)经典动态规划题，算一个字符串转换到另一个字符串的代价，注意多申请一行一列是有必要的
73. (*)使用原来已经存在的空间来做临时存储，与119题有异曲同工之妙
74. (***)两次二分查找，先对第一列使用二分查找找出可能的一行，然后对该行再用二分查找(杨氏矩阵是他的扩充，杨氏矩阵不要求第二行最小的比上一行的都大,杨氏矩阵的关键：查找从右上角或者左下角开始，小左移，大下移；增加时，比较上和左的元素，选出最大的元素交换知道插入值比上和左都大;删除时，比较右和下的元素，选出最小的元素交换;修改，比原来值大相当于删除操作，如果比原来值小，相当于添加操作)
75. (*)双指针一个记录0应该放的位置，一个记录2应该放的位置，这一颗星是因为我没有想到
76. (***)与30题有异曲同工之妙，用map结构来存储出现的数量，这样就不用每次都要计算首部在哪，github大牛的思路是一样的，但是他使用数组来处理更快
77. 不难，常见的回溯递归问题
78. 不难，常见的回溯递归去除重复的问题，是77题的扩展，最好的方法不是用77外面加一个for，而是从头到尾判断每个数是否出现，代码少很多
79. 与螺旋矩阵的题目类似，递归回溯，上下左右的尝试
80. (*)26题的延续用一个指针标记下一个数该放的位置就能解决，这是一类题，leetcode归纳为Two Pointers
81. (**)33题的延续，好题，考验了思维的严密性，如果相等是无法判断属于哪一边的，但是可以判断某一个不是
82. 不难，83题的延续，删除所有重复过的节点，注意开始和结尾，结尾要记得赋值为NULL
83. 不难，指针运算，删除重复的节点每个值只能出现一次，注意开始和结尾的时候，尤其是结尾要赋值为NULL
84. (***)难题，好题，与我的最后一个想法一样，找一个板子，分别向左边和右边找，找到第一个比它值小的，从而找到以它为高度的矩形面积，但是查找需要O(n)，这个算法复杂度为O(N^2)，而github大牛用stack来记录一组非递减的高度，那么stack中栈顶的板子的左界就是下一个板子，而又界就是遇到的第一比它小的，这样查找时间就缩减到O(1)，很精彩
85. (***)难题，好题，将整个问题转换成84那样的子问题，好好欣赏大牛的程序把
86. 链表运算，两个头一个记录左边一个记录右边，注意开始和结尾的操作
87. (***)好题，解题的关键是你的dp中存储的是什么，我的方法是存储从i到j的所有组合，因为问题值要求给个判断并不是输出所有可能，所以我的方法太大了，也没必要，而且超出内存要求了，而github大牛给的方法是在dp中存储是否能匹配，它使用三维vector前两维分别是s1,s2的下标，第三维是长度，这样的处理是最简洁的，第二遍想还是没想到，我用的也是三维数组但是前两维是s1的区间，第三维只有两个元素表示匹配前面还是匹配后面，我的处理方法在代码实现上会比较复杂
88. 两个排序好的数组整合，唯一的不同是不要申请第三个数组，从后往前(从大到小)将元素放到A数组中
89. 问题的关键是理解什么格雷码(Gray Code)，以及bitset数据结构低位在最右边
90. 不难，在78题基础上加上了可能有重复元素，用传统方法就可以解决，即每一位上相同的数字只能出现一次
91. (***)好题，动态规划，第二次做找到更好的方法，类似70走楼梯，就是需要判断是否能一次走2步(小心无效的编码输入)(老思路：怎么处理每一个子问题以及如何处理出现0的情况（一个是10,20，还有个是在110时），而对于这道题，还有一点值得学习的是在用动态规划的时候，到底使用二维数组还是一维数组这个要通过分析得出，不要盲目的用二维数组)
92. 基础题目，链表操作，注意首尾的操作
93. (*)不难，返回所有可能的ip，思路不难就是回溯，但是有好多细节，ip判断的时候，一个是位数是否合法，一个是数值是否合法
94. (***)本题目是中序遍历的非递归实现,我已经将前序,中序,后续遍历的非递归实现(with stack or without stack)总结到CSDN上了,Morris的线索树的方法很好
95. 我使用回溯+DP反而没有github大牛用回溯的写法快，只能说代码不够优化而且测试集不够大，这题和96题一样主要是回溯+DP二叉查找树都是幌子
96. 动态规划,二叉搜索树有多少种
97. (*)动态规划,s3的最后一个字母一定来自s1或者s2的最后一个,这样根据最后一个字母来自哪里,就可以划分为子问题了
98. (*)判断一棵树是否是二叉搜索树,左右子树都是二叉搜索树,且左子树最大的比根节点小,右子树最小的比根节点大(不能相等)
99. 不难,中序遍历,根据遍历中出现的异常情况标记出被交换的两个点,最后交换两个点的数值
100.判断两棵树是否相等
101.判断一棵树是否是对称的，注意右子树的右节点和左子树的左节点是对应的
102.(*)打印层序遍历结果，使用queue,亮点在于每一层结束时加入一个NULL
103.(*)102题的延伸，queue与stack相结合的遍历
104.简单题，查找数的深度，遍历树到叶子节点再处理即可
105.(***)经典问题，通过前序遍历和中序遍历结果恢复一棵树,必须要理解怎么恢复，然后模拟
106.(*)与105题类似，通过后序遍历和中序遍历的结果恢复一棵树，先理解怎么恢复，然后模拟
107.与102题类似，只是从底下那一层往上打印，可以将102的结果reverse过来即可
108.将排序后的数组转换成高度均衡的BST，递归建树选取最中间的数作为根节点
109.与108题一样,只是本题是排序后的链表,选取中间的数为根节点,然后递归调用
110.判断是否是平衡二叉树,递归判断每个节点左右子树高度相差是否小于1
111.判断一棵树的最小深度,每到一个叶子节点就处理一次看是否是最小深度
112.判断从根节点到叶子节点是否等于给定值,暂存从根节点到父节点的和,每到叶子节点就处理一次
113.112的延伸,在112的基础上在暂存路径上所有的点,github大牛使用vector引用类型加上pop_back操作来避免了形参赋值时的时间开销,也不错
114.不难,将一棵树按先序遍历转换成一个"链表",主要要注意先把左右子树都暂存起来,而且链表的尾指针可能更改,所以要用引用类型
115.(*)DP问题,划表格模拟下就能找到其中的子结构,按照最后一个元素是否相同来划分
116.(*)题目不难,要找到其中的track,用层序遍历,会因为队列的操作而TLE,直接操作,左指向右,右指向下一个节点的左
117.116题的延伸,二叉树不在是完全二叉树,所以不能只操作一个节点,每次要操作一行
118.生成杨氏矩阵,要找到杨氏矩阵的规律
119.(*)118题的延伸,关键是在O(k)的空间内完成,所以要利用头尾的1来暂存结果,这里的输入k不是第k行而是第k+1行
120.简单的DP问题,每个节点表示从根节点到该节点的最小值
121.买卖股票问题1,只能进行一次操作,贪心做法
122.买卖股票问题2,能进行任意多次操作,只要当天比前一天价格高那么就可以买卖
123.(**)买卖股票问题3,只能进行2次操作,很好的DP例子,将第二次的操作用DP存起来,而第一次的操作还像121问题一样处理,这样就能将二维的DP降到一维
124.(***)好题,亮点在与DP+后续遍历,树的题目几乎都可以在每个节点上处理然后递归,本题中节点的val中存储的是从这个节点到它子树中另一个节点的最大值
125.简单题,判断一个字符串是不是回文(忽略掉非字母和数字的值),可以用isalnum来判断是否是字母或数字
126.(***)是127题的延续，就是在BFS广度优先遍历的时候，当一个string与当前字符串相差1个字母时的处理比127题复杂罢了，将所有到达A节点步数最少的点都作为A的前一个节点存储在map<string,vector<Node>>里面,然后从end节点往前BFS遍历所有可能
127.(*)BFS题目，一直Runtime Error是因为set的边遍历边删除元素那里没有处理好，至于最后的TLE是因为github的算法每次修改一个字母,并检查是否在dict里面,避免了dict中有多个重复元素，还是很值得回味的
128.(*)可以用priority_queue来做,set,map中希望按照自己的意思排序,可以使用优先队列完成
129.不难,递归调用,在叶子节点处进行处理就好
130.(***)题是个好题，使用DFS或者BFS都可以,但是要用两个引用变量vector和flags,vector存储遍历过得O,flags标识是否全部被包围
131.(*)插入分割版,使字符串s变成回文的,dfs遍历所有的可能,亮点在于用DP来判断是否是回文,不用2个DP也能过
132.(**)131题延伸,返回使得s变成回文使用最少分割版的个数,使用2个DP,一个用于判断子串是否是回文,另一个用于记录将子串变成回文的所需要的分割版个数(第二个DP用一维的就ok)
133.(*)复制一个无向图,使用一个map遍历一遍
134.(*)简单模拟,到达每个点需要消耗一定资源并获得一定资源,遍历时有一个贪心的track,而且本题是顺时针的,如果不要求方向可以求出sum_gas和sum_cost,若sum_gas>=sum_cost那么max(gas[i])就是满足要求的起点.(第二遍做还是遇到很多坑)
135.(**)很好的贪心问题,从头到尾处理一遍,再从尾到头处理一遍
136.(*)将所有数异或一遍即可,出现偶数次的问题都可以这么处理
137.(*)是136题的推广,本题是这类问题的一般解法,统计所有数的每一bit位上1的个数,然后mod N,本题中N为3
138.(*)与133题类似,复制一个随机链表,使用map<ListNode*,ListNode*>,然后遍历一遍,<剑指offer>有一种不用map的算法很好
139.典型的深度优先遍历+DP
140.(*)是139题的延伸,在DFS的同时用DP记录所有可行的组合
141.(***)快慢指针判断一个链表中是否存在环
142.(***)判断链表中是否有环,如果有指出环的开始位置,用快慢指针判断是否有环,然后计算出环的大小,让快慢指针距离为环的大小从头在走一遍(这次走的速度相同),当他们相等时即为环开始位置
143.(*)链表的操作,先将后半部分逆序,然后将前半部分和后半部分一个一个取出来排列
144.(***)树的先序遍历,非递归
145.(***)树的后续遍历,非递归
146.(*)设计题LRU,需要考虑三点:快速查询是否在cache中(用map);数据命中后需要更新先后顺序(用list,map中value是list的迭代器);当cache已经满后要替换掉最早的数据(list也要存key值)
147.链表的插入排序,想好怎么操作链表就好
148.(*)链表的二分排序,面试常见题
149.(**)返回在同一条直线上的点的最大值,map中存储斜率,对于每个点计算从该点出发的最值情况,小心平行于y轴的直线以及与选取点相同的点
150.(*)计算逆波兰式,数字(大数)入栈,计算符号出栈计算再入栈
151.(***)将一个字符串以单词为单位逆序,两次翻转
152.DP问题,求连续子串的最大的积,DP节点存储从该点到最后一个节点的子串积的最大值和最小值
153.在旋转后的数组中找到最小的元素(没有重复的元素)
154.(*)难点在于存在重复的元素,在相等的时候无法判断是在哪一边只好减少一个元素(low++)即可
155.(*)设计题目,设计一个最小栈,使用一个辅助stack,小心重复的最小值,leetcode上是在<=时才入辅助栈,而<剑指offer>是每添加一个元素就把当前最小值入辅助栈
160.(*)返回两个链表的结合点,1颗星是因为他经常出现在面试题目中,统计两个链表的长度,长的链表先走几步,然后相遇点就是结合点
162.(**)二分查找的一个变形,别人分析的比我深入,所以代码比我简洁
164.(***)利用桶排序的思想但是有很大不同,先找出所有数中的min和max,划分成n+1个桶,每个桶只用记录该桶内的最大值和最小值即可
165.判断两个版本号是否相同,每次遇到'.'便进行操作,注意1与1.0是同一个版本
166.(*)模拟除法,将余数用set标记,如果出现之前有过的余数便处理
168.将正整数转化为Excel中的列号,注意Z的处理
169.(*)找到序列中出现次数超过一半的元素，后一个元素与前一个元素不同则次数减一，当次数达到0时用新元素替换，最后剩下的元素就是所求元素
171.是168的变形，类似于26进制
172.(*)统计N的阶乘中，后面的零的个数，即统计5的个数，不要对每个数进行处理，直接算N中5出现1次的数量，5出现2次的数量，5出现3次的数量......
173.(***)设计题，一种使用栈的中序非递归遍历二叉树的
174.(**)王子从左上角到右下角救出公主，血量不能小于等于0，本题中只能从右下角到左上角进行处理
179.(**)给出一些数，将这些数组成一个最大的数，根据AB>BA，A就排在B前面对数序列排序，然后按照这个顺序组成数字
187.(**)亮点在于用2bit表示一个字符(只有4种)，一个int就足够存储10个字符，用set<int>来存储所有的，用来看之前是否存在
188.(***)买卖股票问题4,能进行K次操作,把局部最优和全局最优相结合求解问题，local[j]是第i天进行了j次操作，且最后一次发生在第i天的局部最大收益，max(local[j] + diff, global[j - 1] + max(diff, 0))的意思是，前i-1天进行了j此操作，只是把最后一次的操作的卖出放到第i天，第二项是前i-1天进行了j-1次操作，最后一天如果比前一天价值高那么就前一天买第i天卖(收益位diff),否则就当天买当天卖(收益位0),然后取他们两个的最大值作为局部最优
189.(***)将一个数组以一个中心点交换左右两边，即实现rotate函数，通过不断的交换，将元素放到它该放的地方
190.(*)翻转一个32位int的bit位，使用位运算实现，而且使用两个静态变量实现多次调用的性能提升
191.(***)统计一个32位数中有多少bit位是1,利用n&(n-1)的方法,该方法还可以用来判断n是不是2的k次幂
198.小偷偷东西，不能偷相邻房间，一维DP实现，存储从这个房间到最后一个房间最多能偷多少
199.(*)返回右视图，树的后续遍历，每个子函数返回以该节点为根节点的树的右视图，然后将左右结果合并再加上根节点（也可以进行先遍历右节点的先序遍历，根据高度打印）
200.BFS统计有多少个小岛，所有连在一起的1是一个小岛，用sign标识是否遍历过（这类题目，最好将4个方向存在数组中，一个for循环就可以遍历4个方向）
201.(*)统计从m到n之间所有数AND运算的结果，只用处理m和n两个数就可以了，找到最高的位置m为0，n中为1，这个最高位后面的位置都将reset为0
202.Happy Number，用set存储之前出现过的数字，如果新出现的在set上那么返回false，如果等于1了返回true
203.链表操作，删除所有值为val的节点，小心头位置
204.(***)对于之前每个的素数，它的整数倍都是不是素数，用sign标识是否为素数，对于每个素数遍历所有整数倍，都不是素数，最后剩下的就是素数(小心越界),大神有O(N)的算法
205.判断两个string是否是同构的，一个字符只能映射到同一个，两个字符不能映射到同一个
206.(***)面试经典题目,链表逆序
207.(***)经典的拓扑排序返回成是否能上完,用set+queue的方法比我之前用遍历找下一个可遍历节点要块很多.
208.(***)Trie树数据结构，经典题目，结构中有两成员:一个用于记录是否有以该节点结束的单词，第二个用于记录下一层映射(我一般用map实现)，即一个字段对应的下一个节点
209.(*)正整数数组中,找到最短的连续子串,他们的和大于给定值,先找到一个满足要求的区间,然后尾部加入一个值,头部不断减少直到正好满足要求(不断更新结果)
210.(*)207的变形,在拓扑排序的同时记录每个节点的顺序
211.(*)208Trie数的应用，在遇到'.'的时候回溯即可
213.(**)是198题的扩展,将房子连城一个环,对第一件房子特殊处理(偷or不偷)就可以将问题分为2个没有环的问题(跟198一样了),然后返回他们的最大一个
214.(***)利用KMP的变形题目，注意他只能在前头加入字母，关键在于找字符串s的反转与s叠加后最短的回文字符串(要对KMP理解才能想到)
215.(***)找到未排序中的第k大的数，经典问题，使用快排实现的时候注意不要出现死循环(去掉隔板)，在大数据范围要使用大顶堆(这样就不用把所有数都放到内存中)
216.组合问题，列出所有用k个1-9的数组成和为n的情况，不能重复
217.(***)面试经典题目,判断是否有重复数字,写代码可以用set写,说思路要说bitmap
218.(***)好题，使用multiset，有点像84题，好好欣赏
219.(*)217的变形,判断是否存在两个int相等,而且他们之间的距离不超过K,先存储K个值,然后移动大小为K的窗口(删除第一个元素,在尾部加入一个元素)
220.(***)好题,是217和219的扩展,一个数组中判断是否存在距离不超过K的两个数的大小在不超过t,先用key=nums[i]%(t+1),再用map<key,nums[i]>这种形式存储,每个长度为t+1区间只保存一个,如果一个区间有两个数返回true,并且这map只维护k-1的长度的值,对于下一个数判断key,key-1,key+1的三中情况是否满足条件即可,如果满足返回true,否则加入并删除头元素(注意:case中有int溢出情况;key=0的元素个数是2*(t+1)因为可以为负数,code时小心)
221.(*)动态规划,85题是长方形，这里是正方形，简单多了，只用考虑之前的三个点,注意DP里面存储的含义(当然85题的方法也可以用)
222.(***)好题,完全二叉树计算节点个数,利用满二叉树的特点,如果该树是满二叉树直接计算,否则为左子树节点+右子树节点+1(避免对满二叉树遍历,很好)
223.(***)好题,两个矩阵叠加后的总面积,在不知不觉中考察了int溢出的问题
224.(***)因为只有加和减,减法可以用加法(加他的负数)来实现,所以只要判断这个数对于最终结构是加还是减即可(小心大数)
225.(*)用queue模拟stack,申请两个queue互相倒
226.将一棵树变成它的对称,对每个节点交换左右子树
227.(*)计算器，同样时间复杂度就是不能过，好像只有转换成逆波兰式可以过
228.(*)输出区间,简单模拟题,注意int可能有多位数(要转化为string),而且会有负数
229.(**)不错,是169题的扩展,找出出现n/3以上的数字,也是用169的思想,不过要用2个num记录最后剩下的2个数,然后判断这两个数是不是要找的(要多遍历一次)
230.(*)就是在BST里面用找topK,与用快排的思路一样,就是它的扩展问题需要记录左节点的个数
231.判断一个数是否是2的阶乘,用&和>>实现，注意优先级
232.(*)用两个栈模拟队列
233.(***)好题，计算1-n所有位中出现1的次数，将n拆成两部分递归处理(剑指offer 32 错误了)
234.快慢指针找到中点，然后反转匹配
235.(*)BST查找最早公共祖先
236.(**)235题目的扩展，在一般树上找最早公共祖先，不用每次都遍历祖先，找到从根节点到目标点的一条链，然后对这两条链处理
237.原地删除链表中的一个节点，直接赋值
238.(**)技巧题，从头到尾遍历一边记录到该点之前的乘积，再从尾到头遍历一边记录之后所有的乘积(顺便把这两个值相乘)
239.(***)使用一个deque，只存储当前窗口中会对之后的选择有影响的元素。插入时每次从队尾进行，每次滑动窗口时只判断队首元素是否超出窗口范围，超出的话则删除。还有就是比较队尾元素与当前元素大小，如果小的话，直接删除队尾元素，否则插入(deque中保存下标即可,否则需要另一个数据结构看第一个元素是否越界)
240.(***)杨氏矩阵,从右上角查找,target比该点值大了向下走,小了向左
241.(***)好题,与95题异曲同工,但是做了一层封装,误以为是计算器+回溯,很好的题目
242.简单题,判断a和b字符串是否只是顺序不同
257.(*)不难,注意int转string的时候,int不只一位而且可以为负数
258.(***)一步求树根,dr(n)=((n-1)mod9)+1
260.(***)经典面试题目,一组数中有两个数只出现一次,其他数字出现2次,找出这两个数,按照某个bit位分为两组,每组数相继异或
263.简单题,判断一个数是否只有2,3,5的因子,处理掉2,3,5因子看是不是为1即可,注意边界负数,0,1
264.(**)面试见过,一组数只由多个2,3,5相乘获得,找出第k个,后面的数都是由前面的数乘以2,3,5获得,分别记录2,3,5乘到哪个位置,每次从这三个位置所对应的数中找到最小即可(小心有坑,有可能出现相同元素,2*3=3*2)
268.(*)判断一组数中第一个没出现的自然数,将每个元素放到他该放的地方即可,然后遍历找出答案
273.将int转化为英语,模拟,每3位处理,将一些关键点用map存起来
274.(*)在n个数中找到一个数h,使得n个数中有h个数大于等于它,有n-h个数小于它,用到计数排序的思想
275.274的扩展,在排好序的情况下直接找就好了
278.(***)二分查找的应用(找第一个bad version),二分的时候一定要小心越界
283.将所有的0移到最后，不能申请多余空间，先将所有非0的数放到它该放的地方并统计0的个数，最后在末尾补零
284.设计题，设计一个子类实现peek()，意思是偷看下一个元素，先将下一个元素读预读出来即可
287.(***)不申请多余空间找出nums[n+1]中重复的一个元素，nums[]都在1-n之间；可以使用二分统计小于等于mid的个数在nlogn时间内完成，最好的方法是将这个数组想成是一个链表，所求的元素就是冲nums[0]开始的环的入口，之后就和以前的题目一样了。
289.(***)根据相邻节点的值跟新本节点的值，要求同一时间更新，而且不能使用额外空间，使用int的4个值代表不同的状态就可以记录变化前和变化后的值
290.给一个模式和一个字符串，看这个字符串是否满足这个模式，使用map+set就可完成


C++语言细节：
1.  如果想在类里面使用sort函数并且要定义谓词，谓词函数必须是静态的 static bool cmp(...)
2.  在子函数中申请的空间在函数结束后不会释放
3.  整数情况要考虑负数，string类型要考虑空，vector要考虑个数为0
4.  类的静态函数不能用非静态变量，但是非静态函数能用静态变量
5.  如果想在b.cc里面用a.cc的变量，可以现在a.hh里面用extern int a声明一个变量，然后a.cc里面初始化，然后在b.cc头文件中加入#include "a.hh"就可以了，但是编译的时候要先编译a.c, eg: (1)g++ a.cc -c (2) g++ b.cc a.o -o b 
6.  用于迭代器的算法，也可以用在指针上面
7.  用new申请二维空间，也要想malloc一样，a=new int*[m]; for:a[i]=new int[n];
8.  string不能初始化为NULL(会出run time error)，只能初始化为空("")
9.  string自带的find函数可以查询子串，如果没有找到返回一个npos值
10. 把INT_MIN取绝对值不能直接取反或者用abs函数，必须先类型转换，eg：0-(long)temp, abs((lng)temp)
11. 在遍历容器并给容器加元素时，加完元素一定要再次更新下标，否则会出现死循环
12. 在使用map的时候对象名称不能取map（会出现编译错误），而且要考虑key值重复出现的情况
13. 模板类只能在.h文件中实现，在cpp文件中实现会报错
14. vector<vector<int> >不能写成vector<vector<int>>，最后的>>要分开写
15. 链表的题要仔细仔细在仔细，做完之后要好好想想头部是否初始化，尾部时候处理（赋值位NULL），还有last=head ...... if(last!=head){} 没有else是永远不会改变last值的81-82题
16. 写完程序后要看看条件判断时不时互补，如果不是仔细想想会不会出错
17. bitset的最低位在最右边
18. 做题的时候将题目条件小点写到纸上，或者做完后在读一边题目
19. 当指针做形参时，如果函数里面要改变指针而不是指针的对象，那么指针必须是引用模式，eg TreeNode *&first.
20. 在处理树结构时，不能只处理题目要求的分支，左右子树都要处理，哪怕是赋值为NULL(114题)，否则OJ会报runtime error
21. 在编译C++11里面的东西的时候，要在后面加上 -std=c++11
22. list,set,map边遍历边删除元素：
        std::list< int> List;
        std::list< int>::iterator itList;
        for( itList = List.begin(); itList != List.end(); )
        {
            if( WillDelete( *itList) )
            {
                itList = List.erase( itList);
            }
            else
                itList++;
        }   
23. 不能将一个NULL的指针存储起来,temp为NULL，stack.push(temp),change(temp)，即使函数传进去的指针的引用，改变的也是temp而不是stack的那个值，这并不是NULL的问题，而是自己逻辑不多，你要存储的是改变后的temp而不是一开始的temp
24. && || 运算都是有短路返回的,所以判断时不时空要往前放
25.sort的cmp函数是static bool cmp(const T &a, const T &b) 必须是bool类型,不是自己认为的int值,而bool的操作和int是有区别的,非0在bool里面就是true,而且当a=b时必须返回false,如果想要升序那么就是return a.value < b.value
26.map的迭代器可以++也可以--,但是不能一个从头往后,一个从后往前,然后根据是否相等结束,当他们指向同一个值时他们并不相等,可以使用key值是否相等来做转换
27.关掉cin与stdin同步(用于保证文件指针不混乱)可以用ios::sync_with_stdio(false);(代价是cin与scanf不能在混用)
28.用(n&0x1) == 0判断是否是偶数必须加上括号，优先级问题
29.(***)以后OJ要想快要(1)用C语言里的printf和scanf;(2)而且在for循环不要用size和strlen之类的函数,要么之前算好,要么直接用!='\0'来判断;(3)能用数组的不要用map,map稍微慢
30.(**)volatile关键字一般与const相对应,被修饰的变量不会被优化,例如每次读该变量会从内存中取,避免了const通过某种渠道更改后但是值不变的问题
31.cin后面不能直接跟getline,否则getline直接因为回车而返回,要在cin后面加上cin.ignore()
32.value/k==0 元素中包括负数,-(k-1) ~ (k-1)都会返回0 (220题有坑)
33.for循环中如果有类似(int*int<=int)的判断时,eg i*j<=n,一定要小心i*j越界变成负数(204题有坑),可以将i和j定义为long
34.C++的cout默认精度是6位,所以输出double的时候一定要小心,尽量不要用cout
35.一般的动态规划问题都可以优化空间复杂度,常见的2维空间可以优化到1维,面试场合下要提出来
36.(***)二分查找类似的题目一定要小心越界,(low+high)是很有可能越界的,所以要声明为long
37.C++中又直接将string转换为int的函数atoi(str.c_str()),stoi(str)；stoi速度更快一点
