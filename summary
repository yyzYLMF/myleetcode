/**********
@Author: yang
content: leetcode summary
**********/

NOTICE:
*	有一些亮点或者是某些重要算法的雏形
**	又再做一遍的必要，可以从中学到知识
***	非常重要的题，必须多做几遍


LEETCODE 总结：
1.	(*)2Sum算法，排序从两头往中间找，可以与后面的3Sum 4Sum一起看
2.	(**)整体很简单就是模拟各个位相加，设置一个进位，但这个题里面有很多细节，2颗星是给他的细节的
3.	简单模拟题，找最长没重复子串，从头开始遍历，如果没有在之前出现过的字母则添加，否则从出现过的位置的下一位开始继续遍历
4.	(***)要求算法复杂度位log(m+n)，这是重点，这道题要转换成找第k大的数，而因为所给的两个数组是已经排过序了所以只用log(m+n)，而编程之美上没没有排序的所以要NlogK
5.	(***)遍历所有对称点而不是起始点，通过增加间隔符将奇偶一起考虑是个亮点，核心算法是Manacher算法（利用之前的结果简化第i点计算）
6.	首先要知道ZigZag什么意思，然后找规律实现
7.	从后往前按位处理就好了，最后小心别溢出
8.	最大的难点是要atoi的功能要了解，其他的就是越界问题了
9.	判断是不是回文数，按位处理就好了，小心0
10.	(**)正则表达式匹配，最大的难点是回溯，处理好*情况就ok了（与44题很像）
11.	(*)贪心的遍历，从两头开始向中间汇聚，当然这种算法背后隐含着很多证明
12.	最大的难点是看懂罗马数字和阿拉伯数字转换
13.	同12题
14.	避免同时计算就好了，一个一个比较
15.	(**)3Sum,在2Sum的基础上，先排序，然后从小到大确定第一个元素，然后在后面的区间内用2Sum找到满足要求的下标，避免重复
16.	(**)3Sum closest,与15题类似，只是一个是找相等，一个是找最相似
17.	就是递归，将每个数字对应的所有可能存到map中，然后针对每一位遍历所有可能，注意只有0,1都是空	
18.	(**)4Sum,可以将所有k-sum问题转换成2-sum，这样复杂度就为O(N^(k-1))，但是4Sum可以用hasmap来实现，用hasmap来搜索某个值是否存在只用O(1)，所以2Sum可以是O(n)的，n是遍历一遍，所以4Sum先将两个数的值存到hasmap中，然后遍历前2个数的所有可能，看hasmap中是否存在target-(a1+a2)，最后复杂度就是O(n^2)
19.	设置一个间隔位n的区间，然后设置两个指针分别指向头尾，然后递进，当到达尾部时，头指针为要删除的节点
20.	括号匹配，用栈就ok了
21.	简单题，两个有序链表合并起来(github上大牛给的算法很精炼)
22.	回溯问题，不难，递归调用就ok(github上的大牛方法很简单，不需要用stack来存储是否匹配，只需要记录左右括号的个数)
23.	(**)多个链表合并是21题的延伸，思维不能太局限，原始数据可以用二分处理，数据组也可以用二分处理，时间复杂度为O(NlogK)，github大牛给的使用priority_queue实现是O(N)
24.	交换连表中的两个数，指针操作，写代码前先在纸上模拟可以避免一些错误(大牛很喜欢用指针的指针来操作)
25.	(*)首先是理解题目意思中间是要逆序不是交换，然后剩下的就是链表操作，其中的亮点是如何在不申请多余空间的前提下逆序一个链表(pdf版大牛的递归方法也不错，github大牛的方法没看懂)
26.	简单题，去掉重复获得新的长度，用unique实现，github大牛的方法很精髓
27.	简单题，删除目标值元素并返回剩余长度，因为题目没要求剩余的元素有序，所以把删除的后移就好了
28.	(**)查询是否包含某个子串，使用string自带的find函数，题目最初的意思是自己实现，用KMP算法再做一遍
29.	(***)这是个好题，用减法来实现除法，但是将被除数想成(2^n+...+..)*除数的形式来处理，github上的算法虽然代码简洁，但是思路和我的一样而且效率不一定高
30.	(**)返回L中元素出现在S中的位置，关键是如何判断S的子串是L中元素的全排列，我的想法虽然与github大牛一样，但是他使用map来进行处理，算法就变得很简洁高效

C++语言细节：
1.	如果想在类里面使用sort函数并且要定义谓词，谓词函数必须是静态的 static bool cmp(...)
2.	在子函数中申请的空间在函数结束后不会释放
3.	整数情况要考虑负数，string类型要考虑空，vector要考虑个数为0
4.	类的静态函数不能用非静态变量，但是非静态函数能用静态变量
5.	如果想在b.cc里面用a.cc的变量，可以现在a.hh里面用extern int a声明一个变量，然后a.cc里面初始化，然后在b.cc头文件中加入#include "a.hh"就可以了，但是编译的时候要先编译a.c, eg: (1)g++ a.cc -c (2) g++ b.cc a.o -o b 
6.	用于迭代器的算法，也可以用在指针上面
7.	用new申请二维空间，也要想malloc一样，a=new int*[m]; for:a[i]=new int[n];
8.	string不能初始化为NULL(会出run time error)，只能初始化为空("")
9.	string自带的find函数可以查询子串，如果没有找到返回一个npos值
10.	把INT_MIN取绝对值不能直接取反或者用abs函数，必须先类型转换，eg：0-(long)temp, abs((lng)temp)
