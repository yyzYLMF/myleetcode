/**********
@Author: yang
content: leetcode summary
**********/

NOTICE:
*   有一些亮点或者是某些重要算法的雏形
**  有再做一遍的必要，可以从中学到知识
*** 非常重要的题，必须多做几遍
(github大牛: github.com/iphkwan/leetcode)

LEETCODE 总结：
1.  (*)2Sum算法，排序从两头往中间找，可以与后面的3Sum 4Sum一起看
2.  (**)整体很简单就是模拟各个位相加，设置一个进位，但这个题里面有很多细节，2颗星是给他的细节的
3.  简单模拟题，找最长没重复子串，从头开始遍历，如果没有在之前出现过的字母则添加，否则从出现过的位置的下一位开始继续遍历
4.  (***)要求算法复杂度位log(m+n)，这是重点，这道题要转换成找第k大的数，而因为所给的两个数组是已经排过序了所以只用log(m+n)，而编程之美上没没有排序的所以要NlogK
5.  (***)遍历所有对称点而不是起始点，通过增加间隔符将奇偶一起考虑是个亮点，核心算法是Manacher算法（利用之前的结果简化第i点计算）
6.  首先要知道ZigZag什么意思，然后找规律实现
7.  从后往前按位处理就好了，最后小心别溢出
8.  最大的难点是要atoi的功能要了解，其他的就是越界问题了
9.  判断是不是回文数，按位处理就好了，小心0
10. (**)正则表达式匹配，最大的难点是回溯，处理好*情况就ok了（与44题很像）
11. (*)贪心的遍历，从两头开始向中间汇聚，当然这种算法背后隐含着很多证明
12. 最大的难点是看懂罗马数字和阿拉伯数字转换
13. 同12题
14. 避免同时计算就好了，一个一个比较
15. (**)3Sum,在2Sum的基础上，先排序，然后从小到大确定第一个元素，然后在后面的区间内用2Sum找到满足要求的下标，避免重复
16. (**)3Sum closest,与15题类似，只是一个是找相等，一个是找最相似
17. 就是递归，将每个数字对应的所有可能存到map中，然后针对每一位遍历所有可能，注意只有0,1都是空  
18. (**)4Sum,可以将所有k-sum问题转换成2-sum，这样复杂度就为O(N^(k-1))，但是4Sum可以用hasmap来实现，用hasmap来搜索某个值是否存在只用O(1)，所以2Sum可以是O(n)的，n是遍历一遍，所以4Sum先将两个数的值存到hasmap中，然后遍历前2个数的所有可能，看hasmap中是否存在target-(a1+a2)，最后复杂度就是O(n^2)
19. 设置一个间隔位n的区间，然后设置两个指针分别指向头尾，然后递进，当到达尾部时，头指针为要删除的节点
20. 括号匹配，用栈就ok了
21. 简单题，两个有序链表合并起来(github上大牛给的算法很精炼)
22. 回溯问题，不难，递归调用就ok(github上的大牛方法很简单，不需要用stack来存储是否匹配，只需要记录左右括号的个数)
23. (**)多个链表合并是21题的延伸，思维不能太局限，原始数据可以用二分处理，数据组也可以用二分处理，时间复杂度为O(NlogK)，github大牛给的使用priority_queue实现是O(N)
24. 交换连表中的两个数，指针操作，写代码前先在纸上模拟可以避免一些错误(大牛很喜欢用指针的指针来操作)
25. (*)首先是理解题目意思中间是要逆序不是交换，然后剩下的就是链表操作，其中的亮点是如何在不申请多余空间的前提下逆序一个链表(pdf版大牛的递归方法也不错，github大牛的方法没看懂)
26. (**)经典题，去掉重复获得新的长度，用unique实现，github大牛的方法很精髓，用github的方法才是正解
27. 简单题，删除目标值元素并返回剩余长度，因为题目没要求剩余的元素有序，所以把删除的后移就好了
28. (**)查询是否包含某个子串，使用string自带的find函数，题目最初的意思是自己实现，用KMP算法再做一遍
29. (***)这是个好题，用减法来实现除法，就是将被除数想成(2^n+...+..)*除数的形式来处理，github上的算法虽然代码简洁，但是思路和我的一样而且效率不一定高
30. (**)返回L中元素出现在S中的位置，关键是如何判断S的子串是L中元素的全排列，我的想法虽然与github大牛一样，但是他使用map来进行处理，算法就变得很简洁高效
31. 不难，关键是要知道什么样的排列是当前排列的下一个排列
32. (**)思路和我的一样，都是在遇到反括号的时候才计算长度并更新，但是github大牛使用了贪心的思想减少了很多计算长度时候的开销，不错
33. 二分查找，就是在mid不等于target的时候多一个判断
34. 二分查找，我的算法虽然AC了但是事件复杂度最差为O(N)，而github大牛的算法是分别用二分查找找出左边和右边的下标（右边的mid=(low+high+1)/2），它的算法是O(longN)
35. 二分查找，当low+1<high时退出，然后逐个分析，github使用mid=(low+high+1)/2方法，然后在对low判断后得出答案，能比我的简洁一点
36. 判断数读是否合理，分别队行、列以及小块进行判断
37. (*)回溯递归，先遍历整个矩阵存储到行、列和小块中，然后递归遍历所有可能，填数字
38. 不难，首先要理解题目意思，是要返回第n个结果，不是“读n”，还有一点是不会出现3个以上连续出现的数字，所以我的程序有点啰嗦
39. 不难，就是典型的递归回溯，本来想用二分法来查找最大的插入值，但是结果反而不好，应该是用到函数调用还有数据规模小导致的
40. 39题的延伸，还是递归回溯，每个元素只能用一次（不是每个值只能出现一次），有一种写法可以不用在写个函数判断重复，就是for循环中保证每次加入的值不会重复就好了
41. (***)好题，这是一类题，将元素放到它该去的地方然后再进行处理，这道题可以通过值来确定它该去的地方，有些题要用一个变量存储它该去的地方
42. (*)一个贪心问题，先找到最大隔板，然后分别从左边和右边遍历，叠加可以灌水的地方
43. (*)经典题目，大数相乘，用乘数从高到低每一位去乘被乘数，然后将结果相加(ab*cde=((ab*c)10+ab*d)*10+ab*e)
44. (**)通配符匹配，虽然与第10题很像，但是这里的*可以匹配任意个任何字符，而正则表达式中的*是前一个字符的任意多次，所以正则表达式匹配用回溯递归来判断*的使用次数不会太多，而通配符使用回溯递归来确定*的使用次数会严重超时，而本题使用贪心+回溯，记录最近一次*出现的位置，每次匹配不成功只回溯到最近的*处。
45. (*)贪心，选择下跳到达位置最远的点作为这次跳越的目的点，能到达地点越远可能性就越多，如果有最优点那么我们算法一定能找到。
46, 全排列，回溯，用一个数组来存储该数是否被使用过（这道题没有要求去掉重复的，47题要求检查重复）
47. (*)46题的延伸，还是回溯但是要去掉重复的，该题去掉重复的方法是我做leetcode时最常用的方法。
48. 不难，几何问题，矩形旋转90度，先按主对角线对折，然后左右翻转
49. (*)首先题目的意思是给一组字符串，找出所有由相同字母组成的字符串，第二次想还是没有想到用map<string,vector<string> >的数据结构，多看看
50. 次方运算，与29题很像，将n看成ak*2^k+...+a0*2^0的形式，而这道题要小心指数为负数的情况
51. (***)经典回溯问题，N皇后问题，就是要小心对角线有两个
52. 和51题基本上一样，一个返回所有可能，一个返回所有可能数目，github大牛用位操作实现的，很简洁（但是感觉掌握不好）
53. (*)求最大和的连续子序列，贪心问题（如果用分治法的画，对于每一个子问题还要记录它最大子序列组成元素的下标，才好合并）
54. 就是一个模拟题，右下左上添加，就是要注意到头后要转向
55. 与45题很像，比45题要求简单，还是贪心做，遇到走不动了返回false
56. 不难，按照开始时间排序，从头到尾遍历，能合并的合并
57. (*)不难，就是一个逻辑严密性的题，和56题一样区间合并
58. 简单题，求最后一个单词的长度
59. 54题的变形，我还是用啰嗦的模拟方法，github大神计算出了对应的关系，每次循环填4个值
60. (***)好题，是46、47题的变形，不过这道题只需要返回第k个排序，所以不需要用递归找出所有结果，第k位应该填几要看剩下的值是(k-1)!的多少倍
61. (*)第二次看还是没理解题目意思，题目是将链表右移N步，N可能大于链表长度
62. 不难，简单的动态规划
63. 不难，与62题很像，就是加了障碍物，注意dp[0][0]位置和初始化情况就ok
64. 不难，与62一样就是加了个外壳，62-64是一个类型的动态规划题
65. (**)判断一个数是否是合理的科学技术法表示的，因为不知道什么形式是正确的，所以比较难，细节要考虑的有：前后的空格；小数点只能出现一次且只能出现在数值部分；e或者E只能出现一次而且出现时之前一定有合法数字；加减号只能出现在首部以及e的后面一位；
66. 简单题，就是大数加一，主要小心所有位都加完了但是进位还为1的时候要在首部加1.
67. 简单题，二进制大数相加
68. (**)复杂模拟题，关键是当下一个单词放不到这一行时该如何处理
69. (*)求x的平方根，在一定区域内二分查找，比方说这道题中x为int型，所以结果肯定小于2^16，为了防止越界还可以用if(x/mid == mid)来做判断
70. 简单题，上楼梯，简单的动态规划
71. 不难，模拟题，每次遇到'/'处理一下，小心几个细节：怎么退栈都会有一个'/'；输入结尾不一定是'/'
72. (*)经典动态规划题，算一个字符串转换到另一个字符串的代价，注意多申请一行一列是有必要的
73. (*)使用原来已经存在的空间来做临时存储，与119题有异曲同工之妙
74. (***)两次二分查找，先对第一列使用二分查找找出可能的一行，然后对该行再用二分查找(杨氏矩阵是他的扩充，杨氏矩阵不要求第二行最小的比上一行的都大,杨氏矩阵的关键：查找从右上角或者左下角开始，小左移，大下移；增加时，比较上和左的元素，选出最大的元素交换知道插入值比上和左都大;删除时，比较右和下的元素，选出最小的元素交换;修改，比原来值大相当于删除操作，如果比原来值小，相当于添加操作)
75. (*)双指针一个记录0应该放的位置，一个记录2应该放的位置，这一颗星是因为我没有想到
76. (***)与30题有异曲同工之妙，用map结构来存储出现的数量，这样就不用每次都要计算首部在哪，github大牛的思路是一样的，但是他使用数组来处理更快
77. 不难，常见的回溯递归问题
78. 不难，常见的回溯递归去除重复的问题，是77题的扩展
79. 与螺旋矩阵的题目类似，递归回溯，上下左右的尝试
80. (*)26题的延续用一个指针标记下一个数该放的位置就能解决，这是一类题，leetcode归纳为Two Pointers
81. (**)33题的延续，好题，考验了思维的严密性，如果相等是无法判断属于哪一边的，但是可以判断某一个不是
82. 不难，83题的延续，删除所有重复过的节点，注意开始和结尾，结尾要记得赋值为NULL
83. 不难，指针运算，删除重复的节点每个值只能出现一次，注意开始和结尾的时候，尤其是结尾要赋值为NULL
84. (***)难题，好题，与我的最后一个想法一样，找一个板子，分别向左边和右边找，找到第一个比它值小的，从而找到以它为高度的矩形面积，但是查找需要O(n)，这个算法复杂度为O(N^2)，而github大牛用stack来记录一组非递减的高度，那么stack中栈顶的板子的左界就是下一个板子，而又界就是遇到的第一比它小的，这样查找时间就缩减到O(1)，很精彩
85. (***)难题，好题，将整个问题转换成84那样的子问题，好好欣赏大牛的程序把
86. 链表运算，两个头一个记录左边一个记录右边，注意开始和结尾的操作
87. (***)好题，解题的关键是你的dp中存储的是什么，我的方法是存储从i到j的所有组合，因为问题值要求给个判断并不是输出所有可能，所以我的方法太大了，也没必要，而且超出内存要求了，而github大牛给的方法是在dp中存储是否能匹配，它使用三维vector前两维分别是s1,s2的下标，第三维是长度，这样的处理是最简洁的，第二遍想还是没想到，我用的也是三维数组但是前两维是s1的区间，第三维只有两个元素表示匹配前面还是匹配后面，我的处理方法在代码实现上会比较复杂
88. 两个排序好的数组整合，唯一的不同是不要申请第三个数组，从后往前(从大到小)将元素放到A数组中
89. 问题的关键是理解什么格雷码(Gray Code)，以及bitset数据结构低位在最右边
90. 不难，在78题基础上加上了可能有重复元素，用传统方法就可以解决，即每一位上相同的数字只能出现一次
91. (***)好题，动态规划，这道题的关键有两点：怎么处理每一个子问题以及如何处理出现0的情况（一个是10,20，还有个是在110时），而对于这道题，还有一点值得学习的是在用动态规划的时候，到底使用二维数组还是一维数组这个要通过分析得出，不要盲目的用二维数组
92. 基础题目，链表操作，注意首尾的操作
93. (*)不难，返回所有可能的ip，思路不难就是回溯，但是有好多细节，ip判断的时候，一个是位数是否合法，一个是数值是否合法
94. (***)本题目是中序遍历的非递归实现,我已经将前序,中序,后续遍历的非递归实现(with stack or without stack)总结到CSDN上了,Morris的线索树的方法很好
95. 我使用回溯+DP反而没有github大牛用回溯的写法快，只能说代码不够优化而且测试集不够大，这题和96题一样主要是回溯+DP二叉查找树都是幌子
96. 动态规划,二叉搜索树有多少种
97. (*)动态规划,s3的最后一个字母一定来自s1或者s2的最后一个,这样根据最后一个字母来自哪里,就可以划分为子问题了
98. (*)判断一棵树是否是平衡二叉树,左右子树都是平衡二叉树,且左子树最大的比根节点小,右子树最小的比根节点大(不能相等)
99. 不难,中序遍历,根据遍历中出现的异常情况标记出被交换的两个点,最后交换两个点的数值
100.判断两棵树是否相等
101.判断一棵树是否是对称的，注意右子树的右节点和左子树的左节点是对应的
102.(*)打印层序遍历结果，使用queue,亮点在于每一层结束时加入一个NULL
103.(*)102题的延伸，queue与stack相结合的遍历
104.简单题，查找数的深度，遍历树到叶子节点再处理即可
105.(***)经典问题，通过前序遍历和中序遍历结果恢复一棵树,必须要理解怎么恢复，然后模拟
106.(*)与105题类似，通过后序遍历和中序遍历的结果恢复一棵树，先理解怎么恢复，然后模拟
107.与102题类似，只是从底下那一层往上打印，可以将102的结果reverse过来即可
108.将排序后的数组转换成高度均衡的BST，递归建树选取最中间的数作为根节点
109.与108题一样,只是本题是排序后的链表,选取中间的数为根节点,然后递归调用
110.判断是否是平衡二叉树,递归判断每个节点左右子树高度相差是否小于1
111.判断一棵树的最小深度,每到一个叶子节点就处理一次看是否是最小深度
112.判断从根节点到叶子节点是否等于给定值,暂存从根节点到父节点的和,每到叶子节点就处理一次
113.112的延伸,在112的基础上在暂存路径上所有的点,github大牛使用vector引用类型加上pop_back操作来避免了形参赋值时的时间开销,也不错
114.不难,将一棵树按先序遍历转换成一个"链表",主要要注意先把左右子树都暂存起来,而且链表的尾指针可能更改,所以要用引用类型
115.(*)DP问题,划表格模拟下就能找到其中的子结构,按照最后一个元素是否相同来划分
116.(*)题目不难,要找到其中的track,用层序遍历,会因为队列的操作而TLE,直接操作,左指向右,右指向下一个节点的左
117.116题的延伸,二叉树不在是完全二叉树,所以不能只操作一个节点,每次要操作一行
118.生成杨氏矩阵,要找到杨氏矩阵的规律
119.(*)118题的延伸,关键是在O(k)的空间内完成,所以要利用头尾的1来暂存结果,这里的输入k不是第k行而是第k+1行
120.简单的DP问题,每个节点表示从根节点到该节点的最小值
121.买卖股票问题1,只能进行一次操作,贪心做法
122.买卖股票问题2,能进行任意多次操作,只要当天比前一天价格高那么就可以买卖
123.(**)买卖股票问题3,只能进行2次操作,很好的DP例子,将第二次的操作用DP存起来,而第一次的操作还像121问题一样处理,这样就能将二维的DP降到一维
124.(***)好题,亮点在与DP+后续遍历,树的题目几乎都可以在每个节点上处理然后递归,本题中节点的val中存储的是从这个节点到它子树中另一个节点的最大值
125.简单题,判断一个字符串是不是回文(忽略掉非字母和数字的值),可以用isalnum来判断是否是字母或数字
126.(***)是127题的延续，就是在BFS广度优先遍历的时候，当一个string与当前字符串相差1个字母时的处理比127题复杂罢了，将所有到达A节点步数最少的点都作为A的前一个节点存储在map<string,vector<Node>>里面,然后从end节点往前BFS遍历所有可能
127.(*)BFS题目，一直Runtime Error是因为set的边遍历边删除元素那里没有处理好，至于最后的TLE是因为github的算法每次修改一个字母,并检查是否在dict里面,避免了dict中有多个重复元素，还是很值得回味的
128.(*)可以用priority_queue来做,set,map中希望按照自己的意思排序,可以使用优先队列完成
129.不难,递归调用,在叶子节点处进行处理就好
130.(***)题是个好题，使用DFS或者BFS都可以,但是要用两个引用变量vector和flags,vector存储遍历过得O,flags标识是否全部被包围
131.(*)插入分割版,使字符串s变成回文的,dfs遍历所有的可能,亮点在于用DP来判断是否是回文
132.(**)131题延伸,返回使得s变成回文使用最少分割版的个数,使用2个DP,一个用于判断子串是否是回文,另一个用于记录将子串变成回文的所需要的分割版个数(第二个DP用一维的就ok)
133.(*)复制一个无向图,使用一个map遍历一遍
134.简单模拟,到达每个点需要消耗一定资源并获得一定资源,看能不能走一圈
135.(**)很好的贪心问题,从头到尾处理一遍,再从尾到头处理一遍
136.(*)将所有数异或一遍即可,出现偶数次的问题都可以这么处理
137.(*)是136题的推广,本题是这类问题的一般解法,统计所有数的每一bit位上1的个数,然后mod N,本题中N为3
138.(*)与133题类似,复制一个随机链表,使用map<ListNode*,ListNode*>,然后遍历一遍
139.典型的深度优先遍历+DP
140.(*)是139题的延伸,在DFS的同时用DP记录所有可行的组合
141.(***)快慢指针判断一个链表中是否存在环
142.(***)判断链表中是否有环,如果有指出环的开始位置,用快慢指针判断是否有环,然后计算出环的大小,让快慢指针距离为环的大小从头在走一遍(这次走的速度相同),当他们相等时即为环开始位置
143.(*)链表的操作,先将后半部分逆序,然后将前半部分和后半部分一个一个取出来排列
144.(***)树的先序遍历,非递归
145.(***)树的后续遍历,非递归
146.(*)设计题LRU,需要考虑三点:快速查询是否在cache中(用map);数据命中后需要更新先后顺序(用list,map中value是list的迭代器);当cache已经满后要替换掉最早的数据(list也要存key值)
147.链表的插入排序,想好怎么操作链表就好
148.(*)链表的二分排序,面试常见题
149.(**)返回在同一条直线上的点的最大值,map中存储斜率,对于每个点计算从该点出发的最值情况,小心平行于y轴的直线以及与选取点相同的点
150.(*)计算逆波兰式,数字(大数)入栈,计算符号出栈计算再入栈
151.(*)将一个字符串以单词为单位逆序,最大的问题是处理多余的空格
152.DP问题,求连续子串的最大的积,DP节点存储从该点到最后一个节点的子串积的最大值和最小值
153.在旋转后的数组中找到最小的元素(没有重复的元素)
154.(*)难点在于存在重复的元素,在相等的时候无法判断是在哪一边只好减少一个元素(low++)即可
155.(*)设计题目,设计一个最小栈,使用一个辅助stack,小心重复的最小值,leetcode上是在<=时才入辅助栈,而<剑指offer>是每添加一个元素就把当前最小值入辅助栈
160.(*)返回两个链表的结合点,1颗星是因为他经常出现在面试题目中,统计两个链表的长度,长的链表先走几步,然后相遇点就是结合点
162.(**)二分查找的一个变形,别人分析的比我深入,所以代码比我简洁
164.(**)桶排序,基数排序是数据范围不大时候使用,桶排序是数据范围大但是分布均匀时使用
188.(***)买卖股票问题4,能进行K次操作,把局部最优和全局最优相结合求解问题，local[j]是第i天进行了j次操作，且最后一次发生在第i天的局部最大收益，max(local[j] + diff, global[j - 1] + max(diff, 0))的意思是，前i-1天进行了j此操作，只是把最后一次的操作的卖出放到第i天，第二项是前i-1天进行了j-1次操作，最后一天如果比前一天价值高那么就前一天买第i天卖(收益位diff),否则就当天买当天卖(收益位0),然后取他们两个的最大值作为局部最优


C++语言细节：
1.  如果想在类里面使用sort函数并且要定义谓词，谓词函数必须是静态的 static bool cmp(...)
2.  在子函数中申请的空间在函数结束后不会释放
3.  整数情况要考虑负数，string类型要考虑空，vector要考虑个数为0
4.  类的静态函数不能用非静态变量，但是非静态函数能用静态变量
5.  如果想在b.cc里面用a.cc的变量，可以现在a.hh里面用extern int a声明一个变量，然后a.cc里面初始化，然后在b.cc头文件中加入#include "a.hh"就可以了，但是编译的时候要先编译a.c, eg: (1)g++ a.cc -c (2) g++ b.cc a.o -o b 
6.  用于迭代器的算法，也可以用在指针上面
7.  用new申请二维空间，也要想malloc一样，a=new int*[m]; for:a[i]=new int[n];
8.  string不能初始化为NULL(会出run time error)，只能初始化为空("")
9.  string自带的find函数可以查询子串，如果没有找到返回一个npos值
10. 把INT_MIN取绝对值不能直接取反或者用abs函数，必须先类型转换，eg：0-(long)temp, abs((lng)temp)
11. 在遍历容器并给容器加元素时，加完元素一定要再次更新下标，否则会出现死循环
12. 在使用map的时候对象名称不能取map（会出现编译错误），而且要考虑key值重复出现的情况
13. 模板类只能在.h文件中实现，在cpp文件中实现会报错
14. vector<vector<int> >不能写成vector<vector<int>>，最后的>>要分开写
15. 链表的题要仔细仔细在仔细，做完之后要好好想想头部是否初始化，尾部时候处理（赋值位NULL），还有last=head ...... if(last!=head){} 没有else是永远不会改变last值的81-82题
16. 写完程序后要看看条件判断时不时互补，如果不是仔细想想会不会出错
17. bitset的最低位在最右边
18. 做题的时候将题目条件小点写到纸上，或者做完后在读一边题目
19. 当指针做形参时，如果函数里面要改变指针而不是指针的对象，那么指针必须是引用模式，eg TreeNode *&first.
20. 在处理树结构时，不能只处理题目要求的分支，左右子树都要处理，哪怕是赋值为NULL(114题)，否则OJ会报runtime error
21. 在编译C++11里面的东西的时候，要在后面加上 -std=c++11
22. list,set,map边遍历边删除元素：
        std::list< int> List;
        std::list< int>::iterator itList;
        for( itList = List.begin(); itList != List.end(); )
        {
            if( WillDelete( *itList) )
            {
                itList = List.erase( itList);
            }
            else
                itList++;
        }   
23. 不能将一个NULL的指针存储起来,temp为NULL，stack.push(temp),change(temp)，即使函数传进去的指针的引用，改变的也是temp而不是stack的那个值，这并不是NULL的问题，而是自己逻辑不多，你要存储的是改变后的temp而不是一开始的temp
24. && || 运算都是有短路返回的,所以判断时不时空要往前放
25.sort的cmp函数是static bool cmp(const T &a, const T &b) 必须是bool类型,不是自己人为的int值,而bool的操作和int是有区别的,非0在bool里面就是true,而且当a=b时必须返回false,如果想要升序那么就是return a.value < b.value
26.map的迭代器可以++也可以--,但是不能一个从头往后,一个从后往前,然后根据是否相等结束,当他们指向同一个值时他们并不相等,可以使用key值是否相等来做转换
